# DP（Dynamic Programming）动态规划

## 1. 定义

- 前提：如果一个问题，可以从**小规模**逐渐**扩张**到**大规模**，**每一步**都可以**用固定的转移方式**
- 那么：这一个问题拆成几个子问题，分别求解这些子问题，即可推断出大问题的解。

## 2. 内在原理：[归纳总结法](_2_1_归纳总结法.md)

- 首先必须假设，当前步之前得到的都是最优的
- 在假设的条件之上，转移方程向前，得到的仍是最优的
- 结论：递推是成立的


## 2. 我们如何判断一个问题能否使用DP解决呢？

　　能将大问题拆成几个小问题，且满足**无后效性**、**最优子结构**性质。

- 【无后效性】　
  - 一旦f(n)确定，“我们如何凑出f(n)”就再也用不着了。　要求出f(15)，只需要知道f(14),f(10),f(4)的值，而f(14),f(10),f(4)是如何算出来的，对之后的问题没有影响。　　
  - “未来与过去无关”，这就是**无后效性**。
- 【最优子结构】　　
  - 回顾我们对f(n)的定义：我们记“凑出n所需的最少钞票数量”为f(n).　f(n)的定义就已经蕴含了“最优”。
  - 利用w=14,10,4的最优解，我们即可算出w=15的最优解。　　
  - 大问题的最优解可以由小问题的最优解推出，这个性质叫做“**最优子结构性质**”。

## 3.【DP的核心思想】　　

- DP为什么会快？　　
  - 无论是DP还是暴力，我们的算法都是在可能解空间内，寻找最优解。　　
  - 来看钞票问题。**暴力做法**是枚举所有的可能解，这是**最大的可能解空间**。　　DP是枚举有希望成为答案的解。这个空间比暴力的小得多。　　
  - 也就是说：**DP自带剪枝。**　
  - DP舍弃了一大堆不可能成为最优解的答案。譬如：　　15 = 5+5+5 被考虑了。　　15 = 5+5+1+1+1+1+1 从来没有考虑过，因为这不可能成为最优解。
  - 从而我们可以得到DP的核心思想：尽量缩小可能解空间。　　
- 在暴力算法中，可能解空间往往是指数级的大小；如果我们采用DP，那么有可能把解空间的大小降到多项式级
  - 一般来说，解空间越小，寻找解就越快。这样就完成了优化。


## 例子

1. 最长上升子序列
    - 问题的答案是什么：从num[i]作为结尾的长度最长的子序列中，选出最长的那个
    - 上一状态：f(num[i]) = f(num[i-1]) + 1，如果num[i-1]小于num[i]
    - 从上一状态转到下一状态的**公式**
