# KMP算法

## 1、为什么kmp有动态规划？

- KMP需要依靠pat的**dp状态转移矩阵**，来确定是否**到达**了匹配的**最终状态**，进而确定当前匹配到了pat字符串。
- 而，pat的**状态转移矩阵的建立**可以看作一个**动态规划的过程**！！！

## 2、什么是状态转移矩阵？

我们的**目的**是想要在txt字符串中，对pat串进行匹配。观察`txt = 'aaaaab'` 和 `pat='aaab'`。

- 不使用KMP时，我们的暴力方法要对txt中每个字符作为开头，遍历pat，以确定是否匹配。
- 但明显当我们匹配txt第一个子串`aaaa`和`aaab`时发现不匹配，则要从pat头开始从头遍历，以判断下一个子串`aaaa`和`aaab`。
- 当进行到第三个子串`aaab`时，终于匹配到

观察上面的过程，可以发现，有很多多余的操作。以人类的角度，我们根本没必要回到pat的开头，遍历一遍判断。我们只会直接把pat中唯一的`b`和txt的倒数3个字符进行判断，相等，则匹配到了。

这种人类的角度，蕴含了状态转移的思想。

状态转移矩阵保证我们，遇到txt什么字符，我们可以从pat的转移矩阵知道，我们下一步是匹配**下一个pat字符**，还是要**退回到合适的地方**。直到我们匹配到了转移矩阵的最终状态。


## 2、状态转移矩阵的建立

1. 初步理解转移矩阵
   - dp[M][256]，保存着pat的M个字符，[256]代表着每个字符后面接任意一个字符时，我们应该跳到dp[M][256]中的哪一个字符。然后再次接另一个字符。——直到txt结束，或者达到了dp[M][256]的最终状态M。
   - 整个转移矩阵是在确定一件事情：txt种的当前字符i是什么？对于pat串中i位置后面，遇到字符串txt中的j字符后，应该匹配下一个字符？还是应该**回退到哪**？

2. 对于两种状态转移：
   1. 当前字符匹配到了：从dp[i]跳到到dp[i+1]
   2. 当前字符不匹配：回退，退多少？正常来说要退到开头，但是这样就和暴力法没什么区别。KMP的不匹配时的状态转移，体现的就是动态规划的思想，它把当前**回退到哪这个问题**交给子结构来解决！！！也就是求助于动态规划的最优子结构的思想。
   3. 哪里来的子结构？？？假设当前匹配到了pat=`abababb`中的`ababab`，也就是说，txt中现在有一个`ababab`，但是txt下一个字符是什么我们不知道！！如果是`b`，当然就完美结束了，可是如果是`a`呢？和pat串不匹配，我们大可以从pat头开始下一次匹配，但是没必要！！因为我们发现当是`a`时，txt子串`abababa`的后半部分`ababa`是不是仍然是pat串的一部分？所以我们只需要回退到pat的`ababa`处